#!/bin/bash

NONGIT_OK=1
. "$(dirname $0)"/helpers/init.sh
helper canonicalize_path
helper mt_llvm_svn
helper mt_llvm_svn2git

usage() {
    printf "%s\n"                                                             \
        "usage: $(print_cmdname) [options] <name>"                            \
        ""                                                                    \
        "   --config-dir=<dir>"                                               \
        "                   Config directory to find <name>.mt-config in"     \
        "   --git-dir=<dir> Git directory to use (default: $DEFAULT_GIT_DIR)" \
        "   --[no-]setup    Set up and update remotes (default: on)"          \
        "   --[no-]push     Push to the destination(s) (default: on)"         \
        "   --dry-run       Don't actually generate anything"                 \
        "   --show-{monorepo,splitref}-destination"                           \
        "                   Show the monorepo or splitref desitnation repo"   \
        "   --list-actions  List generate actions in order (and exit)"        \
        "   --list-repos    List repos (and exit)"                            \
        "   --list-branches List branches to generate (and exit)"             \
        "   --list-dirs     List declared dirs (and exit)"                    \
        "   --list-(active|inactive|repeat)-dirs=<branch>"                    \
        "                   List active, inactive, or repeated dirs for"      \
        "                   <branch> (and exit)"                              \
        "   --list-(active|inactive|repeat|all)-refdirs=<branch>"             \
        "                   List active, inactive, repeated, or all dirs for" \
        "                   <branch> in <ref>:<dir> format (and exit)"
}

DEFAULT_CONFIG_DIR="$(
    relative_canonicalize_path "$APPLE_LLVM_LIBEXEC_DIR/../../mt-config")"
DEFAULT_GIT_DIR=mt-repo.git

print_list() {
    local list="$1"
    shift
    local which="$list"
    case "$list" in
        --show-monorepo-destination) show_monorepo_destination; return $? ;;
        --show-splitref-destination) show_splitref_destination; return $? ;;
        *) true ;;
    esac

    which="${which#--list-}"
    which="${which%%=*}"
    which="${which//-/_}"

    is_function print_"$which" || usage_error "unknown option '$list'"
    print_"$which" "$@"
}
print_actions() {
    cat "$MT_CONFIG" | sort | awk '$1 == "generate" {print $3, $4}'
}
print_repos() { cat "$MT_CONFIG" | awk '$1 == "repo" {print $2, $3}'; }
print_branches() { print_actions | awk '$1 == "branch" {print $2}' | sort; }
print_dirs() {
    cat "$MT_CONFIG" | awk '$1 == "declare-dir" {print $2}' | sort
}
print_repeat() {
    awk -v branch="$1" '
    $1 == "repeat" && $2 == branch {
        if (any) {
            printf "error: %s:%s: second repeat for branch %s\n" >"/dev/stderr"
            exit 1
        }
        print $3
        any = 1
    }' "$MT_CONFIG"
}
print_active_dirs()      { print_dirs_impl "$1" 1 0 0 0 0; }
print_inactive_dirs()    { print_dirs_impl "$1" 0 1 0 0 0; }
print_repeat_dirs()      { print_dirs_impl "$1" 0 0 1 0 0; }
print_active_refdirs()   { print_dirs_impl "$1" 1 0 0 1 0; }
print_inactive_refdirs() { print_dirs_impl "$1" 0 1 0 1 0; }
print_repeat_refdirs()   { print_dirs_impl "$1" 0 0 1 1 0; }
print_all_refdirs()      { print_dirs_impl "$1" 1 1 1 1 0; }
print_undeclared_dirs()  { print_dirs_impl "$1" 1 0 0 0 1; }
print_dirs_impl() {
    local branch="$1" undecl=$6
    awk_helper mt-config-dirs -v branch="$branch" -v active=$2              \
        -v inactive=$3 -v repeat=$4 -v refs=$5 -v undecl=$undecl            \
        "$MT_CONFIG" "$MT_CONFIG"
}

show_monorepo_destination() { show_destination monorepo; }
show_splitref_destination() { show_destination splitref; }
show_destination() {
    cat "$MT_CONFIG" |
    awk -v which="$1" '
    $1 == "destination" && $2 == which {
        if (destination) {
            destination = destination " " $3
            count = count + 1
        } else {
            destination = $3
            count = 1
        }
    }
    END {
      if (count == 0) {
          printf "error: no %s destination specified\n", which >"/dev/stderr"
          exit 1
      }
      if (count > 1) {
          printf "error: multiple %s destinations specified: %s\n", \
            which, destination >"/dev/stderr"
          exit 1
      }
      print destination
    }'
}

mt_setup() {
    GIT_DIR="$(canonicalize_path "$GIT_DIR")"
    MT_CONFIG="$(canonicalize_path "$MT_CONFIG")"

    # Always change directory.
    if ! should_setup; then
        run cd "$GIT_DIR"
        return $?
    fi

    # Verbose output.
    local gitout=/dev/null
    local hide=--hide-errors
    if [ ! "${VERBOSE:-0}" = 0 ]; then
        gitout=/dev/stdout
        hide=
    fi

    log "Setting up and syncing $GIT_DIR"
    log "  (based on $MT_CONFIG)"
    [ -d "$GIT_DIR" ] ||
        run --hide-errors git init --bare "$GIT_DIR" >$gitout ||
        error "failed to initialize '$GIT_DIR'"
    run cd "$GIT_DIR" || exit 1
    log "Updating remotes in parallel"

    print_repos | {
        local forks= sleepnext=0
        while read name url; do
            # Wait a second if the previous iteration needed a fresh clone.
            sleep $sleepnext
            [ -d "$clone" ]
            sleep_next=$?

            log "  - $name"
            clone=clones/$name.git
            if [ -d "$clone" ]; then
                run $hide git --git-dir $clone remote update >$gitout ||
                    error "failed to update remote '$name'"
            else
                {
                    run $hide mkdir -p $(dirname $clone) >$gitout &&
                    run $hide git clone --mirror $url $clone >$gitout &&
                    run $hide git remote add $name $PWD/$clone >$gitout
                } ||
                    error "failed to mirror remote '$name'"
            fi &
            forks="$forks $!"
        done
        wait $forks
    } || return 1

    log "Combining object databases"
    print_repos |
    while read name url; do
        log "  - $name"
        run $hide git fetch --no-tags $name >$gitout ||
        error "failed to sync '$GIT_DIR'"
    done
}

has_no_spaces() { [ "${1/ /}" = "$1" ]; }
mt_generate() {
    local action="$1"
    local object="$2"
    local generator="mt_generate_$action"

    mt_llvm_svn2git_init ||
        error "generate: could not initialize svn2git"

    # Check that we have a generator for this.
    is_function "$generator" ||
        error "generate: unknown action '$action'"

    # Check for a non-empty argument with no spaces.
    [ -n "$object" ] ||
        error "generate: missing action '$action'"
    has_no_spaces "$object" ||
        error "generate: invalid object '$object'"

    log "Generating $action from $object"
    $generator "$object" || exit 1
}

mt_generate_mapping() {
    local remote=$1
    local branches="$(git show-ref | awk '{print $2}' |
    grep ^refs/remotes/$remote)"

    [ -n "$branches" ] || error "no branches found under '$remote'"
    local branch rev
    for branch in $branches; do
        rev=$(mt_llvm_svn $branch) ||
            error "generate mapping: '$branch' has no LLVM revision"
        if (mt_llvm_svn2git "$rev" >/dev/null); then
            log "Mapping for '$branch' up-to-date"
            continue
        fi
        log "Generating mapping for '$branch'"
        run --dry git apple-llvm mt llvm-svn2git-map $branch ||
            error "failed to generate mapping for '$branch'"
    done
}

mt_generate_branch() {
    # Get the branch name and prepend refs/heads/.
    local heads=refs/heads/
    local rawbranch=$1
    local branch=$rawbranch
    [ "${branch:0:${#heads}}" = $heads ] || branch=$heads$branch

    local refdirs repeatdirs inactivedirs
    refdirs="$(print_active_refdirs "$rawbranch")" ||
        error "failed to extract active refdirs for $rawbranch"
    repeat="$(print_repeat "$rawbranch")" ||
        error "failed to extract any repeat directive for $rawbranch"

    [ -n "$refdirs" ] ||
        error "generate $branch: no 'dir' declarations"

    local refdir ref dir
    for refdir in $refdirs; do
        ref=${refdir%:*}
        dir=${refdir#*:}
        [ "$refdir" = "$ref:$dir" ] ||
            error "generate $branch: invalid 'dir' with colon '$refdir'"
        run --dry git rev-parse $ref^{commit} >/dev/null ||
            error "generate $branch: invalid ref '$ref' in dir '$dir'"
        [ "$dir" = "*" ] &&
            error "generate $branch: invalid dir '$dir' for ref '$ref'"
    done
    if [ -n "$repeat" ]; then
        [ "${repeat:0:${#heads}}" = $heads ] || repeat=$heads$repeat
        run --dry git rev-parse $repeat^{commit} >/dev/null ||
            error "generate $branch: invalid repeat ref '$ref'"
    fi

    refdirs="$(print_all_refdirs "$rawbranch")" ||
        error "failed to extract complete refdirs for $rawbranch"
    run --dry git apple-llvm mt split2mono-translate-branch $branch $refdirs ||
        error "failed to generate branch '$branch'"
}

mt_generate_splitrefs() {
    # Get the branch name and prepend refs/heads/.
    local heads=refs/heads/
    local rawbranch=$1
    local branch=$rawbranch
    [ "${branch:0:${#heads}}" = $heads ] || branch=$heads$branch

    local refdirs="$(cat "$MT_CONFIG" |
    awk -v branch=$rawbranch '$1=="dir"&&$2==branch{print $4":"$3}')"
    local repeat="$(cat "$MT_CONFIG" |
    awk -v branch=$rawbranch '$1=="repeat"&&$2==branch{print $3}')"

    [ -n "$refdirs" ] ||
        error "generate $branch: no 'dir' declarations"
    [ -z "$repeat" ] || error "generate: splitrefs does not support repeat"

    local refdir ref dir
    for refdir in $refdirs; do
        ref=${refdir%:*}
        dir=${refdir#*:}
        [ "$refdir" = "$ref:$dir" ] ||
            error "generate $branch: invalid 'dir' with colon '$refdir'"
        run git rev-parse $ref^{commit} >/dev/null ||
            error "generate $branch: invalid ref '$ref' in dir '$dir'"
        [ "$dir" = "*" ] &&
            error "generate $branch: invalid dir '$dir' for ref '$ref'"
    done

    run --dry git apple-llvm mt split2mono-update-splitrefs \
        $branch $refdirs ||
        error "failed to update splitrefs for '$branch'"
}

CONFIG_DIR="$DEFAULT_CONFIG_DIR"
GIT_DIR=$DEFAULT_GIT_DIR
SETUP=1
should_setup() { [ ! "${SETUP:-0}" = 0 ]; }
NAME=
while [ $# -gt 0 ]; do
    case "$1" in
        --config-dir|--config-dir=*)
            parse_cmdline_option --config-dir CONFIG_DIR "$@"
            shift $?
            [ -n "$CONFIG_DIR" ] || usage_error "--config-dir cannot be empty"
            [ -d "$CONFIG_DIR" ] ||
                usage_error "expected config dir '$CONFIG_DIR' to be directory"
            ;;
        --git-dir|--git-dir=*)
            parse_cmdline_option --git-dir GIT_DIR "$@"
            shift $?
            [ -n "$GIT_DIR" ] || usage_error "--git-dir cannot be empty"
            ;;
        --dry-run)  DRY_RUN=1; shift ;;
        --setup)    SETUP=1; shift ;;
        --no-setup) SETUP=0; shift ;;
        --list-*-*dirs|--list-*-*dirs=*)
            LIST="$1"
            parse_cmdline_option "--list-*-*dirs" LIST_BRANCH "$@"
            shift $?
            [ -n "$LIST_BRANCH" ] ||
                usage_error "${LIST%=} requires an argument"
            ;;
        --list-repeat|--list-repeat=*)
            LIST="$1"
            parse_cmdline_option "--list-repeat" LIST_BRANCH "$@"
            shift $?
            [ -n "$LIST_BRANCH" ] ||
                usage_error "${LIST%=} requires an argument"
            ;;
        --list-*=*) usage_error "unknown option '$1'" ;;
        --list-*|--show-*) LIST="$1"; shift ;;
        --help|--usage|-h) usage; exit 0 ;;
        -*) usage_error "unknown option '$1'" ;;
        *)
            [ -z "$NAME" ] || usage_error "too many positional arguments"
            [ -n "$1" ] || usage_error "empty name for downstream"
            has_no_spaces "$1" || usage_error "branch name '$1' has spaces"
            NAME=$1
            MT_CONFIG="$CONFIG_DIR/$NAME.mt-config"
            [ -r "$MT_CONFIG" ] ||
                usage_error "cannot read '$MT_CONFIG'"
            shift
            ;;
    esac
done

[ -n "$MT_CONFIG" ] || usage_error "missing name of mt-config"
if [ -n "$LIST" ]; then
    print_list "$LIST" "$LIST_BRANCH"
    exit $?
fi

mt_setup || exit 1
print_actions |
while read action object; do
    mt_generate "$action" "$object" ||
        error "failed to generate '$action' using '$object'"
done
exit $?
