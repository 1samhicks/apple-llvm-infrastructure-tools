#!/bin/bash

export NONGIT_OK=1
. "$(dirname $0)"/helpers/init.sh
helper canonicalize_path

usage() {
    printf "%s\n"                                                           \
        "usage: $(print_cmdname) [options] <downstream>"                    \
        ""                                                                  \
        "   --git-dir=<dir>   Git directory to use (default: $DEFAULT_GIT_DIR)"
}

APPLE_LLVM_MT_CONFIG="$(
    relative_canonicalize_path "$APPLE_LLVM_LIBEXEC_DIR/../../mt-config")"
print_repos() { cat "$MT_CONFIG" | awk '$1 == "repo" {print $2, $3}'; }

mt_setup() {
    log "setting up mt in $GIT_DIR"
    log "           using $MT_CONFIG"
    [ -d "$GIT_DIR" ] ||
        run git init --bare "$GIT_DIR"
    print_repos | {
        local forks= sleepnext=0
        while read name url; do
            # Wait a second if the previous iteration needed a fresh clone.
            sleep $sleepnext
            [ -d "$clone" ]
            sleep_next=$?

            clone="$GIT_DIR"/clones/$name.git
            if [ -d "$clone" ]; then
                run git --git-dir $clone remote update
            else
                run mkdir -p $(dirname $clone)
                run git clone --mirror $url $clone
                run git --git-dir "$GIT_DIR" remote add $name $PWD/$clone
            fi &
            forks="$forks $!"
        done
        wait $forks
    } &&
    run git --git-dir "$GIT_DIR" fetch --no-tags --all
}

has_no_spaces() { [ "${1/ /}" = "$1" ]; }
mt_generate() {
    local action="$1"
    local object="$2"
    local generator="mt_generate_$action"

    # Check that we have a generator for this.
    is_function "$generator" ||
        error "generate: unknown action '$action'"

    # Check for a non-empty argument with no spaces.
    [ -n "$object" ] ||
        error "generate: missing action '$action'"
    has_no_spaces "$object" ||
        error "generate: invalid object '$object'"

    log "Generating $action from $object"
    $generator "$object"
}

mt_generate_mapping() {
    local remote=$1
    local branches="$(git --git-dir "$GIT_DIR" show-ref |
    grep ^refs/remotes/$remote)"

    [ -n "$branches" ] || error "no branches found under '$remote'"
    local branch
    for branch in $branches; do
        run git --git-dir "$GIT_DIR" apple-llvm mt llvm-svn2git-map $branch
    done
}

mt_generate_branch() {
    # Get the branch name and prepend refs/heads/.
    local heads=refs/heads/
    local branch=$1
    [ "${branch:0:${#heads}}" = $heads ] || branch=$heads$branch

    local refdirs="$(cat "$MT_CONFIG" |
    awk -v branch=$branch '$1=="dir"&&$2==branch{print $4":"$3}')"
    local repeat="$(cat "$MT_CONFIG" |
    awk -v branch=$branch '$1=="repeat"&&$2==branch{print $3}')"

    local refdir ref dir
    for refdir in $refdirs; do
        ref=${ref%:*}
        dir=${dir#*:}
        [ "$refdir" = "$ref:$dir" ] ||
            error "generate $branch: invalid 'dir' with colon '$refdir'"
        run git --git-dir "$GIT_DIR" rev-parse $ref^{commit} >/dev/null ||
            error "generate $branch: invalid ref '$ref' in dir '$dir'"
        [ "$dir" = "*" ] &&
            error "generate $branch: invalid dir '$dir' for ref '$ref'"
    done

    if [ -n "$repeat" ]; then
        [ "${repeat:0:${#heads}}" = $heads ] || repeat=$heads$repeat
        run git --git-dir "$GIT_DIR" rev-parse $repeat^{commit} >/dev/null ||
            error "generate $branch: invalid repeat ref '$ref'"
    fi

    run git --git-dir "$GIT_DIR" apple-llvm mt split2mono-translate-branch \
        ${repeat:+--repeat }$repeat $branch $refdirs
}

DEFAULT_GIT_DIR=mt-repo.git
GIT_DIR=$DEFAULT_GIT_DIR
if [ "${1%%=*}" = "--git-dir" ]; then
    parse_cmdline_option --git-dir GIT_DIR "$@"
    shift $?
    [ -n "$GIT_DIR" ] || error "--git-dir cannot be empty"
fi

[ $# -ge 1 ] || error "missing mt-config name"
[ $# -le 1 ] || error "too many positional arguments"

NAME="$1"
MT_CONFIG="$APPLE_LLVM_MT_CONFIG/$NAME.mt-config"
[ -f "$MT_CONFIG" ] ||
    error "config for '$NAME' not found at '$MT_CONFIG'"

#mt_setup
cat "$MT_CONFIG" | sort | awk '$1 == "generate" {print $3, $4}' |
while read action object; do
    mt_generate "$action" "$object" ||
        error "failed to generate '$action' using '$object'"
done
exit $?
