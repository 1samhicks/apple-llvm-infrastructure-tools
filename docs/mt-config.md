# git-apple-llvm: mt-config

mt-config files consists of declarations of:

- `upstream`, for an upstream mt-config;
- `repo`, for remote repositories;
- `destination`, for declaring where to publish the generated refs;
- `declare-dir`, for declaring the full set of split directories;
- `repeat`, for repeating commits from another generated branch;
- `dir`, for declaring which remote refs to use for directory content;
- `start`, for specifying where to start a tag/branch;
- `generate`, for declaring what to generate;
- `tags-refs`, for `generate tags`, to list tag patterns to find; and
- `tags-dest`, for `generate tags`, to specify the prefix for generated tags.

See also the last section for a description of the algorithms.

## `upstream`: Declaring an upstream mt-config

```
upstream <name>
```

where `<name>` is the name of the mt-config.  The filename is expected to be
`<name>.mt-config`, adjacent to the config being processed.

`upstream` allows generated monorepos to cascade, ensuring that a downstream
shares all the refs for an intermediate upstream.  For example, one could
imagine the following declaration in `internal.mt-config`:

```
upstream apple
```

This would cause `internal.mt-config` to be built on top of `apple.mt-config`,
ensuring that commits mapped by `apple.mt-config` had identical hashes in
`internal.mt-config`.

## `repo`: Declaring a repository

```
repo <name> <url>
```

where `<name>` is the local name for the remote and `<url>` is its URL.

## `destination`: Declaring a destination remote.

```
destination ( monorepo | splitref ) <repo>
```

where `<repo>` is the local name for the remote.  There are separate
declarations for generated monorepo refs (the main goal) and split repo refs
(for tracking what has been translated).  These are fetched before generating
anything (except when `--no-setup`) and pushed after (except when `--no-push`).

## `declare-dir`: Declaring a directory

```
declare-dir <name>
```

where `<name>` is the name of a directory that comes from a different split
repository and `-` declares the monorepo root.  Any directory not declared here
will be assumed to be part of the monorepo root.  All non-root directories
should be declared even if there are no downstream changes.

See also `dir`, below.

## Defining a branch

Branches are generated by interleaving commits from the associated `<dir>` and
`<repeat>` declarations.

### `repeat`: Interleaving one generated branch's commits into another

```
repeat <branch> <upstream>
repeat <branch> <upstream>{no-pass}
repeat <tag>    <upstream>
repeat <tag>    <upstream>{no-pass}
```

Every time there is a commit to `<upstream>`, generate a merge commit on
`<branch>` that pulls it in, excluding any changes matching `dir` directives.

This can be useful to generate consistent histories "as if" an automerger had
been pulling in all changes from an upstream branch, when in fact some
repositories had a single branch being used for two purposes.

If `{no-pass}` is added as a suffix, then repeated commits will only be added
if there's another non-repeat to process.  In other words, the generated merges
will not"pass" the commits translated by `dir` directives.

### `dir`: Generating commits from a split repo

```
dir <branch>  (<name> | '-') <source> dir<tag>(<name> | '-')<source>
dir <tags-id> (<name> | '-') <source>/*
```

`dir` declares the repositories to interleave to generate `<branch>`.  The
commits are taken from `<source>`, which is expected to be a commitish (branch,
tag, commit hash, etc.) from one of the `repo` declarations, and interleaved
into `<branch>` at the directory named `<name>/`.

`<name>` must have been previously declared with `declare-dir`.

`-` can be given instead of `<name>`, which cause `<source>`'s contents to be
"dereferenced" and put at the root.  This is intended for downstream repos of
<https://git.llvm.org/git/monorepo-root.git>.  It's recommended that these
repos only have blobs; all subdirectories should be in a separate split
repository.

## `start`: A generated ref to start translation from

```
start <branch> <ref>
start <branch> <ref>[no-pass]
start <tag>    <ref>
start <tag>    <ref>[no-pass]
```

A ref to use as a starting point when generating a new `<branch>` or a `<tag>`.

If `[no-pass]` is specified, then a first-parent ancestor of `<ref>` is
automatically chosen which is not newer than any to-be-translated ref from
`dir` directives (this is similar to `repeat`'s `[no-pass]` flag).

## `generate`: What to do, and in what order

```
generate <type> <object>
```

`generate` declares what to do, critically specifying an order of action.  The
declared actions will be completed in the order found in the file.

The currently supported values for `<type>` are:

- `mapping`: generate an svn2git mapping from all the branches in the remote
  named `<object>`.
- `branch`: generate a branch named `<object>`, using the associated `start`,
  `repeat`, and `dir` declarations.
- `tag`: generate a tag named `<object>`, using the associated `start`,
  `repeat`, and `dir` declarations.
- `tags`: define patterns for generating tags, using the associated
  `tags-refs`, `tags-dest`, and `dir` declarations.
    - `<object>` is an abstract identifier used to tie the `generate` command
      with the directives.
    - `tags-refs` can be specified multiple times.
    - `dir` and `tags-dest` directives must both end with `/*` (or be `*`).
    - The tags to translate are found by listing all refs that match something
      in `tags-refs` prefixed by the `dir` pattern.
    - The destination tag is constructed by joining the `tags-refs` pattern
      with `tags-dest`.
- `splitrefs`: create splitrefs ending in `/mt-split` for the given
  pseudo-branch, updating anything that has already been mapped.
    - Like `branch`, looks for `dir` declarations.  `repeat` is not supported.
    - Only useful as a follow-up to the `mapping` command.
    - This optimization reduces work in `branch` directives by calculating and
      efficiently caching the implicitly mapped svn2git commits.

## `tags-refs`: Specify some tag refs to translate

```
tags-refs <tags-id> <pattern>
```

Specify a ref pattern to find under `dir` and generate to `tags-dest`.

## `tags-dest`: Specify where to put generated tags

```
tags-dest <tags-id> <tag-name>/*
tags-dest <tags-id> *
```

## Generation algorithm documentation

### How to create a merge commit

This is referenced below.

- Get the right tree hashes together
- Choose a first parent:
    - If there's a start commit:
        - Use the start commit
    - Else:
        - The earliest commit in `git merge-base --independent`
        - Break ties with order of `dir` directives (or anything deterministic
          and predictable, but doesn't have to be meaningful)
- Drop other parents, where:
    - Content matches first parent AND
    - They are ancestors of the first parent
- If there is one commit left:
    - Use it as the merge commit
- Else
    - Create a merge commit

### How to interleave "new" commits

This is referenced in branch and tag algorithms.

- Sort "new" commits by date-order, interleaving between dirs.
- For each commit:
    - If a commit already has a monorepo translation:
        - Skip if it's not in first-parent history
        - Skip if it's not in ancestry-path
        - Merge commit on top of virtual HEAD
        - Update virtual HEAD
    - Else:
        - Translate the commit (logic depends on first-parent history)
        - Update virtual HEAD only if in first-parent history

Note: it's possible that all commits will be skipped.  Another process should
fix it up.  [See logic at end of existing branch.]

### New branch

#### New branch without start ref

- Create start commit:
    - Find earliest first-parent commit to translate, make it first parent
        - If none, skip ahead to "Generate merge commit" in logic for existing
          branch
    - For other dirs, find the first parents of rejected candidates
    - Create merge commit
- Update branch head to start commit
- [continue with existing branch]

#### New branch with start ref

- Update branch head to start ref
- [continue with existing branch]

#### New branch with no-pass start ref

It's not clear if we really need this path for generating branches, but we need
it for generating tags.

- Find start commit:
    - Find earliest first-parent commit to translate (not in start ref)
        - If none, error
    - Return newest first-parent ancestor of start ref that is older than
      earliest commit to translate
- Update branch head to start commit
- [continue with existing branch]

### Existing branch

- Validate heads.
    - If any incoming HEAD is not the ancestor of the target HEAD, create a new
      head (as-if a new branch without a start ref) using the merge base of
      incoming and target.
- Interleave new commits from all dirs
- Generate merge commit between:
    - final interleaved commit (first-parent) and
    - monorepo equivalents of already-translated HEADs.
- Update branch head to merge commit

### Tag

Follow steps for creating a new branch, but make a tag instead.


### Rough sketch of v3 of the algorithm

This moves the listing of commits directly into the C++ program to allow it to
get incremental results and use processing of normal dirs to affect how repeats
are done.  (As of time of writing, the algorithm has shifted from the below,
but it's fairly close to what's implemented.)

 1. Find the dir commits to interleave.  Ignore repeats until later.
    - For each dir:
        - If it has a start commit:
            - If not ancestor of goal, back up to the merge base.
            - List "first" side of ancestry path (equivalent to first parents,
              if that's in the ancestry path).
        - Else:
            - Look at (all) first parents.
    - Note each commit's timestamp for later sorting, fudging it if necessary
      to be monotonically non-decreasing.
 2. Discard HEAD if any of the `dir` or `repeat` heads aren't ancestors.
 3. Mark which commits have been translated.
    - For each dir:
        - Do a binary search to find where the transition happens.
 4. Sort by commit timestamp, interleaving commits (no translation yet).
    - Stable sort will respect topological order because of commit timestamp
      fudging above.
 5. Fast-forward through the interleaved commits to find the first commit to
    translate, refining the start commits.
    - Keep track of the last commit for each dir before finding the first
      interleaved commit to translate.
        - This becomes the start commit for that dir (even if that dir has more
          already-translated commits).
        - Note whether it's a change from the original start commit.
    - Check for commit timestamp tie-breakers that are already translated,
      and reorder locally as if we had sorted this way above.
 6. Convert start commits to monorepo commits.
 7. Find the repeat commits to interleave.
    - If start is not an ancestor of the goal, discard it.
    - List first parents of the goal, unless there are no commits to translate
      and all other heads can fast-forward to it.
        - Stop at timestamps of any monorepo start commits (or goals, if there
          are no start commits) that are not ancestors of the repeat goal.
        - Stop of the head of the branch (which could also be an ancestor).
    - Filter out commits that don't modify repeated paths.
        - That can mean going back a little further to find a relevant head.
 8. Sort repeat commits, interleaving with other commits by commit timestamp.
 9. Create or refine the starting HEAD, unless there are no start commits.
    - If HEAD was not discarded earlier, use it as the first parent.
    - Prune parents that are not independent and whose content matches the
      first parent.
    - If there's only one parent left use it.  Otherwise, create a merge
      commit.
10. Work forward translating and merging the interleaved commits onto HEAD.
    - If the commit is already translated, merge it into HEAD.
        - If there are multiple commits at the same commit date, merge them at
          the same time.
    - Else:
        - Translate any untranslated parent commits found in the lookup above.
        - Translate the commit on top of HEAD.
11. Merge the goal commits, if necessary.
